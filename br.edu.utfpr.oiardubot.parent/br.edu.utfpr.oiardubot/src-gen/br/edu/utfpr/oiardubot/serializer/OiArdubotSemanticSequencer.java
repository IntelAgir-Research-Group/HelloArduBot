/*
 * generated by Xtext 2.25.0
 */
package br.edu.utfpr.oiardubot.serializer;

import br.edu.utfpr.oiardubot.oiArdubot.Andar;
import br.edu.utfpr.oiardubot.oiArdubot.Bip;
import br.edu.utfpr.oiardubot.oiArdubot.Caso;
import br.edu.utfpr.oiardubot.oiArdubot.Codigo;
import br.edu.utfpr.oiardubot.oiArdubot.Constante;
import br.edu.utfpr.oiardubot.oiArdubot.ConstanteVariavel;
import br.edu.utfpr.oiardubot.oiArdubot.Controle;
import br.edu.utfpr.oiardubot.oiArdubot.Desligar;
import br.edu.utfpr.oiardubot.oiArdubot.Enquanto;
import br.edu.utfpr.oiardubot.oiArdubot.Escolha;
import br.edu.utfpr.oiardubot.oiArdubot.Escrever;
import br.edu.utfpr.oiardubot.oiArdubot.Espera;
import br.edu.utfpr.oiardubot.oiArdubot.ExistenteVariavelRecebe;
import br.edu.utfpr.oiardubot.oiArdubot.FimPara;
import br.edu.utfpr.oiardubot.oiArdubot.Fimse;
import br.edu.utfpr.oiardubot.oiArdubot.Funcao;
import br.edu.utfpr.oiardubot.oiArdubot.FuncaoLerAnalogica;
import br.edu.utfpr.oiardubot.oiArdubot.FuncaoLerDigital;
import br.edu.utfpr.oiardubot.oiArdubot.Inteiro;
import br.edu.utfpr.oiardubot.oiArdubot.Ler;
import br.edu.utfpr.oiardubot.oiArdubot.LerAnalogica;
import br.edu.utfpr.oiardubot.oiArdubot.LerDigital;
import br.edu.utfpr.oiardubot.oiArdubot.Ligar;
import br.edu.utfpr.oiardubot.oiArdubot.Logico;
import br.edu.utfpr.oiardubot.oiArdubot.Model;
import br.edu.utfpr.oiardubot.oiArdubot.MotorDC;
import br.edu.utfpr.oiardubot.oiArdubot.Nome;
import br.edu.utfpr.oiardubot.oiArdubot.OiArdubotPackage;
import br.edu.utfpr.oiardubot.oiArdubot.Para;
import br.edu.utfpr.oiardubot.oiArdubot.Parametro;
import br.edu.utfpr.oiardubot.oiArdubot.Parar;
import br.edu.utfpr.oiardubot.oiArdubot.Porta;
import br.edu.utfpr.oiardubot.oiArdubot.PortaAnalogica;
import br.edu.utfpr.oiardubot.oiArdubot.PortaDigital;
import br.edu.utfpr.oiardubot.oiArdubot.ReceberValor;
import br.edu.utfpr.oiardubot.oiArdubot.Repita;
import br.edu.utfpr.oiardubot.oiArdubot.Se;
import br.edu.utfpr.oiardubot.oiArdubot.Senao;
import br.edu.utfpr.oiardubot.oiArdubot.Servo;
import br.edu.utfpr.oiardubot.oiArdubot.Soma;
import br.edu.utfpr.oiardubot.oiArdubot.Tela;
import br.edu.utfpr.oiardubot.oiArdubot.Texto;
import br.edu.utfpr.oiardubot.oiArdubot.Variavel;
import br.edu.utfpr.oiardubot.oiArdubot.VariavelExistente;
import br.edu.utfpr.oiardubot.oiArdubot.VariavelNome;
import br.edu.utfpr.oiardubot.oiArdubot.VariavelOuPorta;
import br.edu.utfpr.oiardubot.services.OiArdubotGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class OiArdubotSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private OiArdubotGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == OiArdubotPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case OiArdubotPackage.ANDAR:
				sequence_Andar(context, (Andar) semanticObject); 
				return; 
			case OiArdubotPackage.BIP:
				sequence_Bip(context, (Bip) semanticObject); 
				return; 
			case OiArdubotPackage.CASO:
				sequence_Caso(context, (Caso) semanticObject); 
				return; 
			case OiArdubotPackage.CODIGO:
				sequence_Codigo(context, (Codigo) semanticObject); 
				return; 
			case OiArdubotPackage.CONSTANTE:
				sequence_Constante(context, (Constante) semanticObject); 
				return; 
			case OiArdubotPackage.CONSTANTE_VARIAVEL:
				sequence_ConstanteVariavel(context, (ConstanteVariavel) semanticObject); 
				return; 
			case OiArdubotPackage.CONTROLE:
				sequence_Controle(context, (Controle) semanticObject); 
				return; 
			case OiArdubotPackage.DESLIGAR:
				sequence_Desligar(context, (Desligar) semanticObject); 
				return; 
			case OiArdubotPackage.ENQUANTO:
				sequence_Enquanto(context, (Enquanto) semanticObject); 
				return; 
			case OiArdubotPackage.ESCOLHA:
				sequence_Escolha(context, (Escolha) semanticObject); 
				return; 
			case OiArdubotPackage.ESCREVER:
				sequence_Escrever(context, (Escrever) semanticObject); 
				return; 
			case OiArdubotPackage.ESPERA:
				sequence_Espera(context, (Espera) semanticObject); 
				return; 
			case OiArdubotPackage.EXISTENTE_VARIAVEL_RECEBE:
				sequence_ExistenteVariavelRecebe(context, (ExistenteVariavelRecebe) semanticObject); 
				return; 
			case OiArdubotPackage.FIM_PARA:
				sequence_FimPara(context, (FimPara) semanticObject); 
				return; 
			case OiArdubotPackage.FIMSE:
				sequence_Fimse(context, (Fimse) semanticObject); 
				return; 
			case OiArdubotPackage.FUNCAO:
				sequence_Funcao(context, (Funcao) semanticObject); 
				return; 
			case OiArdubotPackage.FUNCAO_LER_ANALOGICA:
				sequence_FuncaoLerAnalogica(context, (FuncaoLerAnalogica) semanticObject); 
				return; 
			case OiArdubotPackage.FUNCAO_LER_DIGITAL:
				sequence_FuncaoLerDigital(context, (FuncaoLerDigital) semanticObject); 
				return; 
			case OiArdubotPackage.INTEIRO:
				sequence_Inteiro(context, (Inteiro) semanticObject); 
				return; 
			case OiArdubotPackage.LER:
				sequence_Ler(context, (Ler) semanticObject); 
				return; 
			case OiArdubotPackage.LER_ANALOGICA:
				sequence_LerAnalogica(context, (LerAnalogica) semanticObject); 
				return; 
			case OiArdubotPackage.LER_DIGITAL:
				sequence_LerDigital(context, (LerDigital) semanticObject); 
				return; 
			case OiArdubotPackage.LIGAR:
				sequence_Ligar(context, (Ligar) semanticObject); 
				return; 
			case OiArdubotPackage.LOGICO:
				sequence_Logico(context, (Logico) semanticObject); 
				return; 
			case OiArdubotPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case OiArdubotPackage.MOTOR_DC:
				sequence_MotorDC(context, (MotorDC) semanticObject); 
				return; 
			case OiArdubotPackage.NOME:
				sequence_Nome(context, (Nome) semanticObject); 
				return; 
			case OiArdubotPackage.PARA:
				sequence_Para(context, (Para) semanticObject); 
				return; 
			case OiArdubotPackage.PARAMETRO:
				sequence_Parametro(context, (Parametro) semanticObject); 
				return; 
			case OiArdubotPackage.PARAR:
				sequence_Parar(context, (Parar) semanticObject); 
				return; 
			case OiArdubotPackage.PORTA:
				sequence_Porta(context, (Porta) semanticObject); 
				return; 
			case OiArdubotPackage.PORTA_ANALOGICA:
				sequence_PortaAnalogica(context, (PortaAnalogica) semanticObject); 
				return; 
			case OiArdubotPackage.PORTA_DIGITAL:
				sequence_PortaDigital(context, (PortaDigital) semanticObject); 
				return; 
			case OiArdubotPackage.RECEBER_VALOR:
				sequence_ReceberValor(context, (ReceberValor) semanticObject); 
				return; 
			case OiArdubotPackage.REPITA:
				sequence_Repita(context, (Repita) semanticObject); 
				return; 
			case OiArdubotPackage.SE:
				sequence_Se(context, (Se) semanticObject); 
				return; 
			case OiArdubotPackage.SENAO:
				sequence_Senao(context, (Senao) semanticObject); 
				return; 
			case OiArdubotPackage.SERVO:
				sequence_Servo(context, (Servo) semanticObject); 
				return; 
			case OiArdubotPackage.SOMA:
				sequence_Soma(context, (Soma) semanticObject); 
				return; 
			case OiArdubotPackage.TELA:
				sequence_Tela(context, (Tela) semanticObject); 
				return; 
			case OiArdubotPackage.TEXTO:
				sequence_Texto(context, (Texto) semanticObject); 
				return; 
			case OiArdubotPackage.VARIAVEL:
				sequence_Variavel(context, (Variavel) semanticObject); 
				return; 
			case OiArdubotPackage.VARIAVEL_EXISTENTE:
				sequence_VariavelExistente(context, (VariavelExistente) semanticObject); 
				return; 
			case OiArdubotPackage.VARIAVEL_NOME:
				sequence_VariavelNome(context, (VariavelNome) semanticObject); 
				return; 
			case OiArdubotPackage.VARIAVEL_OU_PORTA:
				sequence_VariavelOuPorta(context, (VariavelOuPorta) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Implementacao returns Andar
	 *     Andar returns Andar
	 *
	 * Constraint:
	 *     (porta=VariavelOuPorta velocidade=INT direcao=Direcao)
	 */
	protected void sequence_Andar(ISerializationContext context, Andar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.ANDAR__PORTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.ANDAR__PORTA));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.ANDAR__VELOCIDADE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.ANDAR__VELOCIDADE));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.ANDAR__DIRECAO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.ANDAR__DIRECAO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndarAccess().getPortaVariavelOuPortaParserRuleCall_2_0(), semanticObject.getPorta());
		feeder.accept(grammarAccess.getAndarAccess().getVelocidadeINTTerminalRuleCall_4_0(), semanticObject.getVelocidade());
		feeder.accept(grammarAccess.getAndarAccess().getDirecaoDirecaoEnumRuleCall_6_0(), semanticObject.getDirecao());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Bip
	 *     Bip returns Bip
	 *
	 * Constraint:
	 *     tipo=TipoBip
	 */
	protected void sequence_Bip(ISerializationContext context, Bip semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.BIP__TIPO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.BIP__TIPO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBipAccess().getTipoTipoBipParserRuleCall_2_0(), semanticObject.getTipo());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Caso returns Caso
	 *
	 * Constraint:
	 *     (valor=TextoOuNumero codigo+=Codigo)
	 */
	protected void sequence_Caso(ISerializationContext context, Caso semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Codigo returns Codigo
	 *
	 * Constraint:
	 *     code+=Implementacao+
	 */
	protected void sequence_Codigo(ISerializationContext context, Codigo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConstanteVariavel returns ConstanteVariavel
	 *
	 * Constraint:
	 *     (tipo=Tipo variavelNome=ID valor=VariavelValor)
	 */
	protected void sequence_ConstanteVariavel(ISerializationContext context, ConstanteVariavel semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.CONSTANTE_VARIAVEL__TIPO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.CONSTANTE_VARIAVEL__TIPO));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.CONSTANTE_VARIAVEL__VARIAVEL_NOME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.CONSTANTE_VARIAVEL__VARIAVEL_NOME));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.CONSTANTE_VARIAVEL__VALOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.CONSTANTE_VARIAVEL__VALOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstanteVariavelAccess().getTipoTipoEnumRuleCall_0_0(), semanticObject.getTipo());
		feeder.accept(grammarAccess.getConstanteVariavelAccess().getVariavelNomeIDTerminalRuleCall_1_0(), semanticObject.getVariavelNome());
		feeder.accept(grammarAccess.getConstanteVariavelAccess().getValorVariavelValorParserRuleCall_3_0(), semanticObject.getValor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Constante returns Constante
	 *
	 * Constraint:
	 *     variavel=ConstanteVariavel
	 */
	protected void sequence_Constante(ISerializationContext context, Constante semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.CONSTANTE__VARIAVEL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.CONSTANTE__VARIAVEL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getConstanteAccess().getVariavelConstanteVariavelParserRuleCall_1_0(), semanticObject.getVariavel());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Controle returns Controle
	 *
	 * Constraint:
	 *     paras+=Para
	 */
	protected void sequence_Controle(ISerializationContext context, Controle semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Desligar
	 *     Desligar returns Desligar
	 *
	 * Constraint:
	 *     (tipoPorta=TipoPorta porta=Porta)
	 */
	protected void sequence_Desligar(ISerializationContext context, Desligar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.DESLIGAR__TIPO_PORTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.DESLIGAR__TIPO_PORTA));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.DESLIGAR__PORTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.DESLIGAR__PORTA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDesligarAccess().getTipoPortaTipoPortaEnumRuleCall_2_0(), semanticObject.getTipoPorta());
		feeder.accept(grammarAccess.getDesligarAccess().getPortaPortaParserRuleCall_4_0(), semanticObject.getPorta());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Enquanto
	 *     Enquanto returns Enquanto
	 *
	 * Constraint:
	 *     (valorEsquerda=VariavelValor relacao=Logico valorDireita=VariavelValor code+=Implementacao*)
	 */
	protected void sequence_Enquanto(ISerializationContext context, Enquanto semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Escolha
	 *     Escolha returns Escolha
	 *
	 * Constraint:
	 *     (valor=ValorReferencia casos+=Caso+)
	 */
	protected void sequence_Escolha(ISerializationContext context, Escolha semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Escrever
	 *     Escrever returns Escrever
	 *
	 * Constraint:
	 *     mensagem=ConteudoEscrever
	 */
	protected void sequence_Escrever(ISerializationContext context, Escrever semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.ESCREVER__MENSAGEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.ESCREVER__MENSAGEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEscreverAccess().getMensagemConteudoEscreverParserRuleCall_1_0(), semanticObject.getMensagem());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Espera
	 *     Espera returns Espera
	 *
	 * Constraint:
	 *     valor=INT
	 */
	protected void sequence_Espera(ISerializationContext context, Espera semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.ESPERA__VALOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.ESPERA__VALOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEsperaAccess().getValorINTTerminalRuleCall_2_0(), semanticObject.getValor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ExistenteVariavelRecebe returns ExistenteVariavelRecebe
	 *
	 * Constraint:
	 *     name=ValorReferencia
	 */
	protected void sequence_ExistenteVariavelRecebe(ISerializationContext context, ExistenteVariavelRecebe semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.EXISTENTE_VARIAVEL_RECEBE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.EXISTENTE_VARIAVEL_RECEBE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExistenteVariavelRecebeAccess().getNameValorReferenciaParserRuleCall_0_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FimPara returns FimPara
	 *
	 * Constraint:
	 *     name='fimpara'
	 */
	protected void sequence_FimPara(ISerializationContext context, FimPara semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.FIM_PARA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.FIM_PARA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFimParaAccess().getNameFimparaKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Fimse returns Fimse
	 *
	 * Constraint:
	 *     name='fimse'
	 */
	protected void sequence_Fimse(ISerializationContext context, Fimse semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.FIMSE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.FIMSE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFimseAccess().getNameFimseKeyword_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncaoLerAnalogica returns FuncaoLerAnalogica
	 *
	 * Constraint:
	 *     porta=Porta
	 */
	protected void sequence_FuncaoLerAnalogica(ISerializationContext context, FuncaoLerAnalogica semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.FUNCAO_LER_ANALOGICA__PORTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.FUNCAO_LER_ANALOGICA__PORTA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncaoLerAnalogicaAccess().getPortaPortaParserRuleCall_2_0(), semanticObject.getPorta());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FuncaoLerDigital returns FuncaoLerDigital
	 *
	 * Constraint:
	 *     porta=Porta
	 */
	protected void sequence_FuncaoLerDigital(ISerializationContext context, FuncaoLerDigital semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.FUNCAO_LER_DIGITAL__PORTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.FUNCAO_LER_DIGITAL__PORTA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFuncaoLerDigitalAccess().getPortaPortaParserRuleCall_2_0(), semanticObject.getPorta());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Funcao
	 *     Funcao returns Funcao
	 *
	 * Constraint:
	 *     (name=ID parametro=Parametro? tipo=Tipo codigo+=Implementacao* retorno=VariavelValor?)
	 */
	protected void sequence_Funcao(ISerializationContext context, Funcao semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ConteudoEscrever returns Inteiro
	 *     Inteiro returns Inteiro
	 *
	 * Constraint:
	 *     name=INT
	 */
	protected void sequence_Inteiro(ISerializationContext context, Inteiro semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.INTEIRO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.INTEIRO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInteiroAccess().getNameINTTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns LerAnalogica
	 *     LerAnalogica returns LerAnalogica
	 *
	 * Constraint:
	 *     (atribuicao=ReceberValor ler=FuncaoLerAnalogica)
	 */
	protected void sequence_LerAnalogica(ISerializationContext context, LerAnalogica semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.LER_ANALOGICA__ATRIBUICAO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.LER_ANALOGICA__ATRIBUICAO));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.LER_ANALOGICA__LER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.LER_ANALOGICA__LER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLerAnalogicaAccess().getAtribuicaoReceberValorParserRuleCall_0_0(), semanticObject.getAtribuicao());
		feeder.accept(grammarAccess.getLerAnalogicaAccess().getLerFuncaoLerAnalogicaParserRuleCall_1_0(), semanticObject.getLer());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns LerDigital
	 *     LerDigital returns LerDigital
	 *
	 * Constraint:
	 *     (atribuicao=ReceberValor ler=FuncaoLerDigital)
	 */
	protected void sequence_LerDigital(ISerializationContext context, LerDigital semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.LER_DIGITAL__ATRIBUICAO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.LER_DIGITAL__ATRIBUICAO));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.LER_DIGITAL__LER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.LER_DIGITAL__LER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLerDigitalAccess().getAtribuicaoReceberValorParserRuleCall_0_0(), semanticObject.getAtribuicao());
		feeder.accept(grammarAccess.getLerDigitalAccess().getLerFuncaoLerDigitalParserRuleCall_1_0(), semanticObject.getLer());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Ler
	 *     Ler returns Ler
	 *
	 * Constraint:
	 *     (atribuicao=ReceberValor ler=FuncaoLer)
	 */
	protected void sequence_Ler(ISerializationContext context, Ler semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.LER__ATRIBUICAO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.LER__ATRIBUICAO));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.LER__LER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.LER__LER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLerAccess().getAtribuicaoReceberValorParserRuleCall_0_0(), semanticObject.getAtribuicao());
		feeder.accept(grammarAccess.getLerAccess().getLerFuncaoLerParserRuleCall_1_0(), semanticObject.getLer());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Ligar
	 *     Ligar returns Ligar
	 *
	 * Constraint:
	 *     (tipoPorta=TipoPorta porta=Porta)
	 */
	protected void sequence_Ligar(ISerializationContext context, Ligar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.LIGAR__TIPO_PORTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.LIGAR__TIPO_PORTA));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.LIGAR__PORTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.LIGAR__PORTA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLigarAccess().getTipoPortaTipoPortaEnumRuleCall_2_0(), semanticObject.getTipoPorta());
		feeder.accept(grammarAccess.getLigarAccess().getPortaPortaParserRuleCall_4_0(), semanticObject.getPorta());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Logico returns Logico
	 *
	 * Constraint:
	 *     (
	 *         relation='=' | 
	 *         relation='<>' | 
	 *         relation='<' | 
	 *         relation='<=' | 
	 *         relation='>=' | 
	 *         relation='>'
	 *     )
	 */
	protected void sequence_Logico(ISerializationContext context, Logico semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (
	 *         var+='Variaveis'? 
	 *         variaveis+=Variavel* 
	 *         constantes+=Constante* 
	 *         ini+='Inicio' 
	 *         codigo+=Implementacao* 
	 *         fim+='Fim'
	 *     )
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns MotorDC
	 *     MotorDC returns MotorDC
	 *
	 * Constraint:
	 *     (estado=INT direcao=Direcao)
	 */
	protected void sequence_MotorDC(ISerializationContext context, MotorDC semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.MOTOR_DC__ESTADO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.MOTOR_DC__ESTADO));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.MOTOR_DC__DIRECAO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.MOTOR_DC__DIRECAO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMotorDCAccess().getEstadoINTTerminalRuleCall_2_0(), semanticObject.getEstado());
		feeder.accept(grammarAccess.getMotorDCAccess().getDirecaoDirecaoEnumRuleCall_4_0(), semanticObject.getDirecao());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Nome returns Nome
	 *     ConteudoEscrever returns Nome
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Nome(ISerializationContext context, Nome semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.NOME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.NOME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNomeAccess().getNameIDTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Para
	 *     Para returns Para
	 *
	 * Constraint:
	 *     (variavel=ID de=INT ate=INT code+=Implementacao* fimpara=FimPara)
	 */
	protected void sequence_Para(ISerializationContext context, Para semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parametro returns Parametro
	 *
	 * Constraint:
	 *     valor+=VariavelNome+
	 */
	protected void sequence_Parametro(ISerializationContext context, Parametro semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Parar
	 *     Parar returns Parar
	 *
	 * Constraint:
	 *     porta=Porta
	 */
	protected void sequence_Parar(ISerializationContext context, Parar semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.PARAR__PORTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.PARAR__PORTA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPararAccess().getPortaPortaParserRuleCall_2_0(), semanticObject.getPorta());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PortaAnalogica returns PortaAnalogica
	 *
	 * Constraint:
	 *     valor=AnalogicaOuId
	 */
	protected void sequence_PortaAnalogica(ISerializationContext context, PortaAnalogica semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.PORTA_ANALOGICA__VALOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.PORTA_ANALOGICA__VALOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortaAnalogicaAccess().getValorAnalogicaOuIdParserRuleCall_0(), semanticObject.getValor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PortaDigital returns PortaDigital
	 *
	 * Constraint:
	 *     valor=DigitalOuId
	 */
	protected void sequence_PortaDigital(ISerializationContext context, PortaDigital semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.PORTA_DIGITAL__VALOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.PORTA_DIGITAL__VALOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortaDigitalAccess().getValorDigitalOuIdParserRuleCall_0(), semanticObject.getValor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Porta returns Porta
	 *
	 * Constraint:
	 *     (name=PortaDigital | name=PortaAnalogica)
	 */
	protected void sequence_Porta(ISerializationContext context, Porta semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ReceberValor returns ReceberValor
	 *
	 * Constraint:
	 *     (tipo=ExistenteVariavelRecebe | tipo=NovaVariavelRecebe)
	 */
	protected void sequence_ReceberValor(ISerializationContext context, ReceberValor semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Repita
	 *     Repita returns Repita
	 *
	 * Constraint:
	 *     (code+=Implementacao* valorEsquerda=VariavelValor relacao=Logico valorDireita=VariavelValor)
	 */
	protected void sequence_Repita(ISerializationContext context, Repita semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Se
	 *     Se returns Se
	 *
	 * Constraint:
	 *     (
	 *         valorEsquerda=VariavelValor 
	 *         relacao=Logico 
	 *         valorDireita=VariavelValor 
	 *         code+=Implementacao* 
	 *         senao=Senao? 
	 *         fimse=Fimse
	 *     )
	 */
	protected void sequence_Se(ISerializationContext context, Se semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Senao returns Senao
	 *
	 * Constraint:
	 *     code+=Implementacao+
	 */
	protected void sequence_Senao(ISerializationContext context, Senao semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Servo
	 *     Servo returns Servo
	 *
	 * Constraint:
	 *     (porta=VariavelOuPorta posicao=INT)
	 */
	protected void sequence_Servo(ISerializationContext context, Servo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.SERVO__PORTA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.SERVO__PORTA));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.SERVO__POSICAO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.SERVO__POSICAO));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getServoAccess().getPortaVariavelOuPortaParserRuleCall_2_0(), semanticObject.getPorta());
		feeder.accept(grammarAccess.getServoAccess().getPosicaoINTTerminalRuleCall_4_0(), semanticObject.getPosicao());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Soma returns Soma
	 *
	 * Constraint:
	 *     (name=ReceberValor valorEsquerda=VariavelOuNumero valorDireita=VariavelOuNumero)
	 */
	protected void sequence_Soma(ISerializationContext context, Soma semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.SOMA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.SOMA__NAME));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.SOMA__VALOR_ESQUERDA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.SOMA__VALOR_ESQUERDA));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.SOMA__VALOR_DIREITA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.SOMA__VALOR_DIREITA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSomaAccess().getNameReceberValorParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getSomaAccess().getValorEsquerdaVariavelOuNumeroParserRuleCall_1_0(), semanticObject.getValorEsquerda());
		feeder.accept(grammarAccess.getSomaAccess().getValorDireitaVariavelOuNumeroParserRuleCall_3_0(), semanticObject.getValorDireita());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns Tela
	 *     Tela returns Tela
	 *
	 * Constraint:
	 *     mensagem=DisplayValor
	 */
	protected void sequence_Tela(ISerializationContext context, Tela semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.TELA__MENSAGEM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.TELA__MENSAGEM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTelaAccess().getMensagemDisplayValorParserRuleCall_1_0(), semanticObject.getMensagem());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ConteudoEscrever returns Texto
	 *     Texto returns Texto
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_Texto(ISerializationContext context, Texto semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.TEXTO__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.TEXTO__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTextoAccess().getNameSTRINGTerminalRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Implementacao returns VariavelExistente
	 *     VariavelExistente returns VariavelExistente
	 *
	 * Constraint:
	 *     (atribuicao=ExistenteVariavelRecebe valor=VariavelValor)
	 */
	protected void sequence_VariavelExistente(ISerializationContext context, VariavelExistente semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.VARIAVEL_EXISTENTE__ATRIBUICAO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.VARIAVEL_EXISTENTE__ATRIBUICAO));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.VARIAVEL_EXISTENTE__VALOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.VARIAVEL_EXISTENTE__VALOR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariavelExistenteAccess().getAtribuicaoExistenteVariavelRecebeParserRuleCall_0_0(), semanticObject.getAtribuicao());
		feeder.accept(grammarAccess.getVariavelExistenteAccess().getValorVariavelValorParserRuleCall_1_0(), semanticObject.getValor());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     NovaVariavelRecebe returns VariavelNome
	 *     VariavelNome returns VariavelNome
	 *
	 * Constraint:
	 *     (tipo=Tipo name=ID)
	 */
	protected void sequence_VariavelNome(ISerializationContext context, VariavelNome semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.VARIAVEL_NOME__TIPO) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.VARIAVEL_NOME__TIPO));
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.VARIAVEL_NOME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.VARIAVEL_NOME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariavelNomeAccess().getTipoTipoEnumRuleCall_0_0(), semanticObject.getTipo());
		feeder.accept(grammarAccess.getVariavelNomeAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VariavelOuPorta returns VariavelOuPorta
	 *
	 * Constraint:
	 *     name=Porta
	 */
	protected void sequence_VariavelOuPorta(ISerializationContext context, VariavelOuPorta semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, OiArdubotPackage.Literals.VARIAVEL_OU_PORTA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, OiArdubotPackage.Literals.VARIAVEL_OU_PORTA__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariavelOuPortaAccess().getNamePortaParserRuleCall_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Variavel returns Variavel
	 *
	 * Constraint:
	 *     (variavelNome=VariavelNome valor=VariavelValor?)
	 */
	protected void sequence_Variavel(ISerializationContext context, Variavel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
